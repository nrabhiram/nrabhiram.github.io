import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

// define directory path of script (root of frontend)
const __dirname = path.dirname(fileURLToPath(import.meta.url));

// calculates the absolute path of a file, 
// if we provide the relative path, 
// i.e wrt the frontend directory
function toAbsolute(p) {
  return path.resolve(__dirname, p);
}

// checks if the client and server builds exist 
async function verifyBuildsExist() {
  await fs.access(toAbsolute('dist/server/entry-server.js'));
  await fs.access(toAbsolute('dist/client/index.html'));
}

// read the files generated by sapphire,
// return the stuff relevant for rendering pages
async function readSchema() {
  const artifactsPath = path.resolve(__dirname, '../artifacts/artifacts.json');
  const schemaPath = path.resolve(__dirname, '../artifacts/schema.json');
  
  const artifactsJSON = await fs.readFile(artifactsPath, 'utf-8');
  const schemaJSON = await fs.readFile(schemaPath, 'utf-8');

  const artifacts = JSON.parse(artifactsJSON);
  const schema = JSON.parse(schemaJSON);

  const rootRoutes = Object.keys(schema).map(repo => `/${repo}`);
  const otherRoutes = Object.keys(artifacts);
  const routes = ['/', ...rootRoutes, ...otherRoutes];

  return [
    artifacts,
    schema,
    routes
  ];
}

async function createStaticBuildFolder() {
  const staticDirExists = await fs.stat(toAbsolute('dist/static'))
    .then(() => true)
    .catch(() => false);

  if (staticDirExists) {
    // removes the static folder and all of its content
    await fs.rm(toAbsolute('dist/static'), { recursive: true, force: true });
  }

  // creates the static folder and
  // all of its parent directories, in case they don't exist
  // in our case, that's the dist folder
  await fs.mkdir(toAbsolute('dist/static'), { recursive: true });
}

function isRouteNested(url) {
  const pathSegments = url.replace(/^\//, '').split('/'); // remove leading slash
  return pathSegments.length > 1 && pathSegments[0] !== '';
}

function getBaseRouteSchemaKey(url) {
  const pathSegments = url.replace(/^\//, '').split('/');
  
  if (pathSegments.length === 1 && pathSegments[0] === '') {
    return "home";
  }
  
  return pathSegments[0];
}

function getPrimaryRouteData(schema, key) {
  const artifact = schema[key];
  const routeData = {
    name: artifact.name,
    path: artifact.path,
  }
  return routeData;
}

function getSecondaryNavData(artifact) {
  const nestedArtifacts = artifact.artifacts || [];
  const secondaryNavData = {};
  secondaryNavData["path"] = artifact.path;
  secondaryNavData["name"] = artifact.name;
  secondaryNavData["summary"] = artifact.summary;
  secondaryNavData["items"] = [];
  secondaryNavData["categories"] = artifact.categories;
  for (let i = 0; i < nestedArtifacts.length; i++) {
    const nestedArtifact = nestedArtifacts[i];
    const nestedNavItem = getSecondaryNavData(nestedArtifact);
    secondaryNavData.items.push(nestedNavItem);
  }
  return secondaryNavData;
}

function getPagePrimaryNavData(schema) {
  const primaryNavData = [];
  let primaryRouteKeys = Object.keys(schema);
  const primaryNavKeyAndIndex = [];
  
  for (let i = 0; i < primaryRouteKeys.length; i++) {
    const keyVal = primaryRouteKeys[i];
    primaryNavKeyAndIndex.push({ key: keyVal, index: schema[keyVal].metadata.index || 0 });
  }

  const primaryRoutes = primaryNavKeyAndIndex.sort(({ index: aIndex }, { index: bIndex }) => {
    return aIndex - bIndex;
  });

  for (const { key } of primaryRoutes) {
    const routeData = getPrimaryRouteData(schema, key);
    if (key === "home") {
      routeData.path = "/"
    }
    primaryNavData.push(routeData);
  }

  return primaryNavData;
}

function getPageSecondaryNavData(url, schema) {
  let secondaryNavData;
  const isNestedRoute = isRouteNested(url);
  const baseRouteKey = getBaseRouteSchemaKey(url);
  const baseArtifact = schema[baseRouteKey];
  if (isNestedRoute || baseArtifact.artifacts.length > 0) secondaryNavData = getSecondaryNavData(baseArtifact);
  return secondaryNavData;
}

function getArtifactToBeRendered(artifacts, schema, url) {
  if (artifacts[url]) return artifacts[url];
  const schemaKey = url === "/" ? "home" : url.slice(1);
  return schema[schemaKey];
}

// process artifact and return data necessary for rendering purposes
function getArtifactData(artifact) {
  const artifactData = {
    summary: artifact.metadata.summary,
    name: artifact.name,
    path: artifact.path,
    content: artifact.content,
    categories: artifact.metadata.categories,
    date: artifact.metadata.date,
    dateEdited: artifact.metadata.dataEdited,
  };
  
  if (artifact.next) {
    const nextArtifact = artifact.next;
    artifactData.next = {
      path: nextArtifact.path,
      name: nextArtifact.label,
    };
  }

  if (artifact.prev) {
    const prevArtifact = artifact.prev;
    artifactData.prev = {
      path: prevArtifact.path,
      name: prevArtifact.name,
    };
  }

  return artifactData;
}

// writes images for a page from the content directory to the static directory
async function copyArtifactImages(artifact, rootPath) {
  if (artifact?.files && artifact.files.length > 0) {
    for (const file of artifact.files) {
      const sourcePath = path.resolve(rootPath, file.location);
      const destPath = path.resolve(__dirname, 'dist/static', file.location);
      
      try {
        await fs.mkdir(path.dirname(destPath), { recursive: true });
        await fs.copyFile(sourcePath, destPath);
        console.log(`Copied image: ${file.location} ✓`);
      } catch (error) {
        console.error(`Failed to copy ${file.location}:`, error);
      }
    }
  }
}

function createThemeInitScript() {
  return `
    <script>
      function initTheme() {
        const theme = JSON.parse(localStorage.getItem('theme')) || 'light';
        const root = document.documentElement;
        if (theme === 'dark') root.classList.add('dark');
      }
      window.addEventListener('load', initTheme);
      initTheme();
    </script>
  `;
}

function createHydrationDataScript(primaryNavData, secondaryNavData, url, artifact) {
  return `
    <script type="application/json" id="svelteData">
      ${JSON.stringify({ 
        primaryNavData, 
        secondaryNavData, 
        url, 
        artifact: artifact
      })}
    </script>
  `;
}

function getPageHTML(template, rendered, scripts) {
  const { themeScript, dataScript } = scripts;
  const html = template
    .replace('<!--app-theme-->', themeScript)
    .replace('<!--app-head-->', rendered.head + (dataScript || ''))
    .replace('<!--app-html-->', rendered.html || '');
  return html;
}

function getRenderOutputPath(url) {
  const filePath = url === '/' 
    ? toAbsolute('dist/static/index.html') 
    : toAbsolute(`dist/static${url}.html`);
  return filePath;
}

async function writeRenderOutputToPath(filePath, html) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, html);
}

// copy directories recursively
// helper function to copy items from dist/client to dist/static
async function copyDirRecursive(src, dest, filter = () => true) {
  const entries = await fs.readdir(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    
    if (entry.isDirectory()) {
      await fs.mkdir(destPath, { recursive: true });
      await copyDirRecursive(srcPath, destPath, filter);
    } else if (filter(srcPath)) {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

async function generateSite() {
  try {
    try {
      await verifyBuildsExist();
    } catch (error) {
      console.error('Required build files not found. Please run the build command first.');
      process.exit(1);
    }

    let artifacts = {};
    let schema = {};
    let routes = [];

    try {
      let result = await readSchema();
      artifacts = result[0];
      schema = result[1];
      routes = result[2];
    } catch (error) {
      console.error('An error occurred while reading the schema and artifacts:', error);
      process.exit(1);
    }

    const { render } = await import('./dist/server/entry-server.js'); // import the server-side renderer
    let template = await fs.readFile(toAbsolute('dist/client/index.html'), 'utf-8');
    await createStaticBuildFolder();

    const primaryNavData = getPagePrimaryNavData(schema);
    
    // for each route, render and save as HTML file
    for (const url of routes) {
      if (url === "/home") continue;
      
      console.log(`Pre-rendering: ${url}`); 

      const secondaryNavData = getPageSecondaryNavData(url, schema);

      const [rendered, compiledArtifact] = await render(
        url, 
        primaryNavData,
        secondaryNavData, 
        getArtifactToBeRendered(artifacts, schema, url)
      );

      const artifact = getArtifactData(compiledArtifact);

      // the content directory is one level above this script
      await copyArtifactImages(compiledArtifact, toAbsolute('..'));

      const themeScript = createThemeInitScript();
      const dataScript = createHydrationDataScript(
        primaryNavData,
        secondaryNavData,
        url,
        artifact
      );

      const html = getPageHTML(template, rendered, { themeScript, dataScript });
      const filePath = getRenderOutputPath(url);
      await writeRenderOutputToPath(filePath, html);

      console.log(`Rendered at: ${filePath} ✓`);
    }
    
    // copy assets from client build to static folder (excluding HTML file)
    await copyDirRecursive(
      toAbsolute('dist/client'), 
      toAbsolute('dist/static'),
      (file) => !file.endsWith('.html')
    );
    
    console.log('Static site generation is complete!');
  } catch (error) {
    console.error('Error during static site generation:', error);
    process.exit(1);
  }
}

generateSite().catch(err => {
  console.error('Failed to generate static site:', err);
  process.exit(1);
});

import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

// define directory path of script (root of frontend)
const __dirname = path.dirname(fileURLToPath(import.meta.url));

const BASE_URL = process.env.VITE_BASE_URL || 'http://localhost:8081';

// calculates the absolute path of a file, 
// if we provide the relative path, 
// i.e wrt the frontend directory
function toAbsolute(p) {
  return path.resolve(__dirname, p);
}

// checks if the client and server builds exist 
async function verifyBuildsExist() {
  await fs.access(toAbsolute('dist/server/entry-server.js'));
  await fs.access(toAbsolute('dist/client/index.html'));
}

// read the files generated by sapphire,
// return the stuff relevant for rendering pages
async function readSchema() {
  const artifactsPath = path.resolve(__dirname, '../artifacts/artifacts.json');
  const schemaPath = path.resolve(__dirname, '../artifacts/schema.json');
  
  const artifactsJSON = await fs.readFile(artifactsPath, { encoding: 'utf8' });
  const schemaJSON = await fs.readFile(schemaPath, { encoding: 'utf8' });

  const artifacts = JSON.parse(artifactsJSON);
  const schema = JSON.parse(schemaJSON);

  const rootRoutes = Object.keys(schema).map(repo => `/${repo}`);
  const otherRoutes = Object.keys(artifacts);
  const routes = ['/', ...rootRoutes, ...otherRoutes];

  return [
    artifacts,
    schema,
    routes
  ];
}

async function createStaticBuildFolder() {
  const staticDirExists = await fs.stat(toAbsolute('dist/static'))
    .then(() => true)
    .catch(() => false);

  if (staticDirExists) {
    // removes the static folder and all of its content
    await fs.rm(toAbsolute('dist/static'), { recursive: true, force: true });
  }

  // creates the static folder and
  // all of its parent directories, in case they don't exist
  // in our case, that's the dist folder
  await fs.mkdir(toAbsolute('dist/static'), { recursive: true });
}

function isRouteNested(url) {
  const pathSegments = url.replace(/^\//, '').split('/'); // remove leading slash
  return pathSegments.length > 1 && pathSegments[0] !== '';
}

function getBaseRouteSchemaKey(url) {
  const pathSegments = url.replace(/^\//, '').split('/');
  
  if (pathSegments.length === 1 && pathSegments[0] === '') {
    return "home";
  }
  
  return pathSegments[0];
}

function getPrimaryRouteData(schema, key) {
  const artifact = schema[key];
  const routeData = {
    name: artifact.name,
    path: artifact.path,
  }
  return routeData;
}

function getSecondaryNavData(artifact) {
  const nestedArtifacts = artifact.artifacts || [];
  const secondaryNavData = {};
  secondaryNavData["path"] = artifact.path;
  secondaryNavData["name"] = artifact.name;
  secondaryNavData["summary"] = artifact.summary;
  secondaryNavData["items"] = [];
  secondaryNavData["categories"] = artifact.categories;
  for (let i = 0; i < nestedArtifacts.length; i++) {
    const nestedArtifact = nestedArtifacts[i];
    const nestedNavItem = getSecondaryNavData(nestedArtifact);
    secondaryNavData.items.push(nestedNavItem);
  }
  return secondaryNavData;
}

function getPagePrimaryNavData(schema) {
  const primaryNavData = [];
  let primaryRouteKeys = Object.keys(schema);
  const primaryNavKeyAndIndex = [];
  
  for (let i = 0; i < primaryRouteKeys.length; i++) {
    const keyVal = primaryRouteKeys[i];
    primaryNavKeyAndIndex.push({ key: keyVal, index: schema[keyVal].metadata.index || 0 });
  }

  const primaryRoutes = primaryNavKeyAndIndex.sort(({ index: aIndex }, { index: bIndex }) => {
    return aIndex - bIndex;
  });

  for (const { key } of primaryRoutes) {
    const routeData = getPrimaryRouteData(schema, key);
    if (key === "home") {
      routeData.path = "/"
    }
    primaryNavData.push(routeData);
  }

  return primaryNavData;
}

function getPageSecondaryNavData(url, schema) {
  let secondaryNavData;
  const isNestedRoute = isRouteNested(url);
  const baseRouteKey = getBaseRouteSchemaKey(url);
  const baseArtifact = schema[baseRouteKey];
  if (isNestedRoute || baseArtifact.artifacts.length > 0) secondaryNavData = getSecondaryNavData(baseArtifact);
  return secondaryNavData;
}

function getArtifactToBeRendered(artifacts, schema, url) {
  if (artifacts[url]) return artifacts[url];
  const schemaKey = url === "/" ? "home" : url.slice(1);
  return schema[schemaKey];
}

// process artifact and return data necessary for rendering purposes
function getArtifactData(artifact) {
  const artifactData = {
    summary: artifact.metadata.summary,
    name: artifact.name,
    path: artifact.path,
    content: artifact.content,
    categories: artifact.metadata.categories,
    date: artifact.metadata.date,
    dateEdited: artifact.metadata.others ? artifact.metadata.others['data-edited'] : undefined,
  };
  
  if (artifact.next) {
    const nextArtifact = artifact.next;
    artifactData.next = {
      path: nextArtifact.path,
      name: nextArtifact.label,
    };
  }

  if (artifact.prev) {
    const prevArtifact = artifact.prev;
    artifactData.prev = {
      path: prevArtifact.path,
      name: prevArtifact.label,
    };
  }

  return artifactData;
}

// writes images for a page from the content directory to the static directory
async function copyArtifactImages(artifact, rootPath) {
  if (artifact?.files && artifact.files.length > 0) {
    for (const file of artifact.files) {
      const sourcePath = path.resolve(rootPath, file.location);
      const destPath = path.resolve(__dirname, 'dist/static', file.location);
      
      try {
        await fs.mkdir(path.dirname(destPath), { recursive: true });
        await fs.copyFile(sourcePath, destPath);
        console.log(`Copied image: ${file.location} âœ“`);
      } catch (error) {
        console.error(`Failed to copy ${file.location}:`, error);
      }
    }
  }
}

function getPageTitle(artifact) {
  const baseTitle = 'Vaxitas';
  const title = `${baseTitle}${artifact && artifact.name && artifact.name !== baseTitle ? ` | ${artifact.name}` : ''}`;
  return title;
}

function getPageMetaTags(artifact) {
  const title = getPageTitle(artifact);
  const url = `${BASE_URL}${artifact?.path === "/home" ? "" : artifact?.path}`;
  return `
    <title>${title}</title>
    <meta name="title" content="${title}">
    <meta name="description" content="${artifact.summary}">
    <meta name="author" content="Abhiram Reddy">
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="alternate" type="application/atom+xml" title="Posts & Logs" href="${BASE_URL}/feed.atom">
    <meta property="og:title" content="${title}">
    <meta property="og:description" content="${artifact.summary}">
    <meta property="og:locale" content="en_US">
    <meta property="og:image" content="${BASE_URL}/card.png">
    <meta property="og:image:secure_url" content="${BASE_URL}/card.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="1920">
    <meta property="og:image:height" content="1280">
    <meta property="og:site_name" content="Vaxitas">
    <meta property="og:url" content="${url}">
    <meta property="og:type" content="website">
    <meta property="og:published_time" content="${artifact.date}">
    <meta property="og:updated_time" content="${artifact.dateEdited ? artifact.dateEdited : artifact.date}">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@nrabhiram">
    <meta name="twitter:title" content="${title}">
    <meta name="twitter:description" content="${artifact?.summary}">
    <meta name="twitter:image" content="${BASE_URL}/card.png">
    <meta name="twitter:image:secure_url" content="${BASE_URL}/card.png"}>
  `;
}

function createThemeInitScript() {
  return `
    <script>
      function initTheme() {
        const theme = JSON.parse(localStorage.getItem('theme')) || 'light';
        const root = document.documentElement;
        if (theme === 'dark') root.classList.add('dark');
      }
      window.addEventListener('load', initTheme);
      initTheme();
    </script>
  `;
}

function createHydrationDataScript(primaryNavData, secondaryNavData, url, artifact) {
  return `
    <script type="application/json" id="svelteData">
      ${JSON.stringify({ 
        primaryNavData, 
        secondaryNavData, 
        url, 
        artifact: artifact
      })}
    </script>
  `;
}

function createAnalyticsScript() {
  return `
    <script 
      defer src="https://inspectorbee.netlify.app/script.js" 
      data-website-id="ddac1d11-d2e1-4bbf-a460-23b03363351d"
      data-domains="vaxitas.xyz"
    ></script>
  `;
}

function getPageHTML(template, rendered, scripts, content) {
  const { themeScript, dataScript, analyticsScript, metaTags } = scripts;
  const html = template
    .replace('<!--app-theme-->', themeScript)
    .replace('<!--app-head-->', metaTags + (dataScript || '') + analyticsScript)
    .replace('<!--app-html-->', rendered.html || '')
    .replace(/(<[^>]+id="content"[^>]*>)/, `$1${content || ''}`);
  return html;
}

function getRenderOutputPath(url) {
  const filePath = url === '/' 
    ? toAbsolute('dist/static/index.html') 
    : toAbsolute(`dist/static${url}.html`);
  return filePath;
}

async function writeRenderOutputToPath(filePath, html) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, html);
}

// copy directories recursively
// helper function to copy items from dist/client to dist/static
async function copyDirRecursive(src, dest, filter = () => true) {
  const entries = await fs.readdir(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    
    if (entry.isDirectory()) {
      await fs.mkdir(destPath, { recursive: true });
      await copyDirRecursive(srcPath, destPath, filter);
    } else if (filter(srcPath)) {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

function escapeXml(text) {
  if (!text) return '';
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function stripHtmlTags(html) {
  if (!html) return '';
  return html
    .replace(/<[^>]*>/g, '') // remove HTML tags
    .replace(/\s+/g, ' ') // normalize whitespace
    .trim();
}

function createAtomEntry(entry, siteUrl) {
  const indentedContent = entry.htmlContent
    .split('\n')
    .map(line => line.trim() ? `      ${line}` : '')
    .join('\n');

  return `<entry>
    <title>${escapeXml(entry.title)}</title>
    <summary type="text">${escapeXml(entry.summary)}</summary>
    <published>${entry.published}</published>
    <updated>${entry.updated}</updated>
    <link rel="alternate" type="text/html" href="${siteUrl}${entry.path}"/>
    <id>${siteUrl}${entry.path}</id>
    <content type="html">
      <![CDATA[${indentedContent}]]>
    </content>
    ${entry.categories ? entry.categories.map(cat => 
      `<category term="${escapeXml(cat)}"/>`
    ).join('\n    ') : ''}
  </entry>`;
}

function extractFeedEntries(feedArtifacts) {
  const entries = [];
  for (const artifact of feedArtifacts) {
    const date = artifact.date;
    const dateEdited = artifact.dateEdited;
    const url = artifact.path;
    let summary = artifact.summary;

    if (!date) continue; // ignore entries without date

    const contentType = url.startsWith('/blog') ? 'blog' : 'now';
    // to keep things simple, not adding a check for whether content type is already a category
    const categories = [contentType, ...(artifact.categories || [])];

    if (!summary) {
      let contentSnippet = artifact.content.length > 200 ? artifact.content.substring(0, 200) + '...' : artifact.content;
      summary = contentSnippet;
    }

    const entry = {
      title: artifact.name || 'Untitled',
      path: artifact.path,
      published: new Date(date).toISOString(),
      updated: new Date(dateEdited || date).toISOString(),
      summary: stripHtmlTags(summary),
      htmlContent: artifact.content,
      categories: categories
    };

    entries.push(entry);
  }

  entries.sort((a, b) => new Date(b.published) - new Date(a.published));

  return entries;
}

function createAtomFeed(entries, feedInfo) {
  const { title, siteUrl, feedUrl, authorName, authorEmail } = feedInfo;
  const updatedDate = entries.length > 0 ? entries[0].updated : new Date().toISOString();
  
  const atomXml = `<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>${escapeXml(title)}</title>
  <id>${feedUrl}</id>
  <updated>${updatedDate}</updated>
  <link href="${feedUrl}" rel="self"/>
  <link href="${siteUrl}" rel="alternate"/>
  <author>
    <name>${escapeXml(authorName)}</name>
    <email>${escapeXml(authorEmail)}</email>
  </author>
  ${entries.map(entry => createAtomEntry(entry, siteUrl)).join('\n  ')}
</feed>`;
  
  return atomXml;
}

async function generateAtomFeed(artifacts) {
  const siteConfig = {
    siteUrl: 'https://vaxitas.xyz',
    authorName: 'Abhiram Reddy',
    authorEmail: 'abhi@vaxitas.xyz',
  };

  const entries = extractFeedEntries(artifacts);

  const feedInfo = {
    title: 'Vaxitas - Blog Posts and Monthly Logs',
    siteUrl: siteConfig.siteUrl,
    feedUrl: `${siteConfig.siteUrl}/feed.atom`,
    authorName: siteConfig.authorName,
    authorEmail: siteConfig.authorEmail
  };

  const feed = createAtomFeed(entries, feedInfo);
  const utf8BOM = '\uFEFF'; // write with UTF-8 BOM to ensure proper encoding recognition
  await fs.writeFile(toAbsolute('dist/static/feed.atom'), utf8BOM + feed, 'utf8');
  console.log('Generated Atom feed at /feed.atom âœ“');
}

async function generateSite() {
  try {
    try {
      await verifyBuildsExist();
    } catch (error) {
      console.error('Required build files not found. Please run the build command first.');
      process.exit(1);
    }

    let artifacts = {};
    let schema = {};
    let routes = [];

    try {
      let result = await readSchema();
      artifacts = result[0];
      schema = result[1];
      routes = result[2];
    } catch (error) {
      console.error('An error occurred while reading the schema and artifacts:', error);
      process.exit(1);
    }

    const { render } = await import('./dist/server/entry-server.js'); // import the server-side renderer
    let template = await fs.readFile(toAbsolute('dist/client/index.html'), 'utf-8');
    await createStaticBuildFolder();

    const primaryNavData = getPagePrimaryNavData(schema);

    const feedArtifacts = [];
    
    // for each route, render and save as HTML file
    for (const url of routes) {
      if (url === "/home") continue;
      
      console.log(`Pre-rendering: ${url}`); 

      const secondaryNavData = getPageSecondaryNavData(url, schema);

      const [rendered, compiledArtifact] = await render(
        url, 
        primaryNavData,
        secondaryNavData, 
        getArtifactToBeRendered(artifacts, schema, url)
      );

      const artifact = getArtifactData(compiledArtifact);
      const { content, ...artifactWithoutContent } = artifact;

      const isNowPost = url.startsWith("/now") && url !== "/now";
      const isBlogPost = url.startsWith("/blog") && url !== "/blog";

      if (isNowPost || isBlogPost) feedArtifacts.push(artifact);

      // the content directory is one level above this script
      await copyArtifactImages(compiledArtifact, toAbsolute('..'));

      const themeScript = createThemeInitScript();
      const dataScript = createHydrationDataScript(
        primaryNavData,
        secondaryNavData,
        url,
        artifactWithoutContent
      );
      const analyticsScript = createAnalyticsScript();
      const metaTags = getPageMetaTags(artifact);

      const html = getPageHTML(
        template, 
        rendered, 
        { themeScript, dataScript, analyticsScript, metaTags },
        content
      );
      const filePath = getRenderOutputPath(url);
      await writeRenderOutputToPath(filePath, html);

      console.log(`Rendered at: ${filePath} âœ“`);
    }
    
    // copy assets from client build to static folder (excluding HTML file)
    await copyDirRecursive(
      toAbsolute('dist/client'), 
      toAbsolute('dist/static'),
      (file) => !file.endsWith('.html')
    );

    await generateAtomFeed(feedArtifacts);
    
    console.log('Static site generation is complete!');
  } catch (error) {
    console.error('Error during static site generation:', error);
    process.exit(1);
  }
}

generateSite().catch(err => {
  console.error('Failed to generate static site:', err);
  process.exit(1);
});
